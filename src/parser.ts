/* AutoGenerated Code, changes may be overwritten
* INPUT GRAMMAR:
* POKESOL_TEXT :=
*   line1=LINE1 '\n'
*   line2=LINE2 '\n'
*   line3=LINE3 '\n'
*   line4=LINE4 '\n'
*   line5=LINE5
* // 1 行目
* LINE1                 := POKEMON_AND_ITEM_LINE | POKEMON_LINE
* POKEMON_AND_ITEM_LINE := pokemon=POKEMON _ '@' _ item=ITEM
* POKEMON_LINE          := pokemon=POKEMON
* POKEMON               := POKEMON_VALUE
* ITEM                  := ITEM_VALUE
* POKEMON_VALUE         := '[0-9a-zA-Zぁ-んァ-ヶー一-龠・()♂♀%]+'
* ITEM_VALUE            := '[ぁ-んァ-ヶ一]+'
* // 2 行目
* LINE2                     := ABILITY_AND_TERATYPE_LINE | ABILITY_LINE | TERATYPE_LINE
* ABILITY_AND_TERATYPE_LINE := ability=ABILITY ' '+ teratype=TERATYPE
* ABILITY_LINE              := ability=ABILITY
* TERATYPE_LINE             := teratype=TERATYPE
* ABILITY                   := '特性:' value=ABILITY_VALUE
* TERATYPE                  := 'テラスタル:' value=TERATYPE_VALUE
* ABILITY_VALUE             := '[ぁ-んァ-ヶー]+'
* TERATYPE_VALUE            := '[ぁ-んァ-ヶー]+'
* // 3 行目
* LINE3              := NATURE_AND_IV_LINE | NATURE_LINE | IV_LINE
* NATURE_AND_IV_LINE := nature=NATURE ' '+ iv=IV
* NATURE_LINE        := nature=NATURE
* IV_LINE            := iv=IV
* NATURE             := '性格:' value=NATURE_VALUE
* IV                 := '個体値:' h=IV_H? _ a=IV_A? _ b=IV_B? _ c=IV_C? _ d=IV_D? _ s=IV_S?
* IV_H               := 'H' value=IV_VALUE
* IV_A               := 'A' value=IV_VALUE
* IV_B               := 'B' value=IV_VALUE
* IV_C               := 'C' value=IV_VALUE
* IV_D               := 'D' value=IV_VALUE
* IV_S               := 'S' value=IV_VALUE
* NATURE_VALUE       := '[ぁ-ん]+'
* IV_VALUE           := '0|[1-9][0-9]*'
* // 4 行目
* LINE4         := STATS_LINE
* STATS_LINE    := STATS
* STATS         := h=STAT '-' a=STAT '-' b=STAT '-' c=STAT '-' d=STAT '-' s=STAT
* STAT          := ACTUAL_AND_EV | ACTUAL
* ACTUAL_AND_EV := value=ACTUAL_VALUE '\(' ev=EV_VALUE '\)'
* ACTUAL        := value=ACTUAL_VALUE
* ACTUAL_VALUE  := '[1-9][0-9]*'
* EV_VALUE      := '[1-9][0-9]*'
* // 5 行目
* LINE5         := MOVES_LINE
* MOVES_LINE    := FOUR_MOVES | THREE_MOVES | TWO_MOVES | ONE_MOVE
* FOUR_MOVES    := move1=MOVE_VALUE _ '/' _ move2=MOVE_VALUE _ '/' _ move3=MOVE_VALUE _ '/' _ move4=MOVE_VALUE
* THREE_MOVES   := move1=MOVE_VALUE _ '/' _ move2=MOVE_VALUE _ '/' _ move3=MOVE_VALUE
* TWO_MOVES     := move1=MOVE_VALUE _ '/' _ move2=MOVE_VALUE
* ONE_MOVE      := move1=MOVE_VALUE
* MOVE_VALUE    := '[０-９ぁ-んァ-ヶー・]+'
* // 空白
* _ := '\s*'
*/
type Nullable<T> = T | null;
type $$RuleType<T> = () => Nullable<T>;
export interface ASTNodeIntf {
    kind: ASTKinds;
}
export enum ASTKinds {
    POKESOL_TEXT = "POKESOL_TEXT",
    LINE1_1 = "LINE1_1",
    LINE1_2 = "LINE1_2",
    POKEMON_AND_ITEM_LINE = "POKEMON_AND_ITEM_LINE",
    POKEMON_LINE = "POKEMON_LINE",
    POKEMON = "POKEMON",
    ITEM = "ITEM",
    POKEMON_VALUE = "POKEMON_VALUE",
    ITEM_VALUE = "ITEM_VALUE",
    LINE2_1 = "LINE2_1",
    LINE2_2 = "LINE2_2",
    LINE2_3 = "LINE2_3",
    ABILITY_AND_TERATYPE_LINE = "ABILITY_AND_TERATYPE_LINE",
    ABILITY_LINE = "ABILITY_LINE",
    TERATYPE_LINE = "TERATYPE_LINE",
    ABILITY = "ABILITY",
    TERATYPE = "TERATYPE",
    ABILITY_VALUE = "ABILITY_VALUE",
    TERATYPE_VALUE = "TERATYPE_VALUE",
    LINE3_1 = "LINE3_1",
    LINE3_2 = "LINE3_2",
    LINE3_3 = "LINE3_3",
    NATURE_AND_IV_LINE = "NATURE_AND_IV_LINE",
    NATURE_LINE = "NATURE_LINE",
    IV_LINE = "IV_LINE",
    NATURE = "NATURE",
    IV = "IV",
    IV_H = "IV_H",
    IV_A = "IV_A",
    IV_B = "IV_B",
    IV_C = "IV_C",
    IV_D = "IV_D",
    IV_S = "IV_S",
    NATURE_VALUE = "NATURE_VALUE",
    IV_VALUE = "IV_VALUE",
    LINE4 = "LINE4",
    STATS_LINE = "STATS_LINE",
    STATS = "STATS",
    STAT_1 = "STAT_1",
    STAT_2 = "STAT_2",
    ACTUAL_AND_EV = "ACTUAL_AND_EV",
    ACTUAL = "ACTUAL",
    ACTUAL_VALUE = "ACTUAL_VALUE",
    EV_VALUE = "EV_VALUE",
    LINE5 = "LINE5",
    MOVES_LINE_1 = "MOVES_LINE_1",
    MOVES_LINE_2 = "MOVES_LINE_2",
    MOVES_LINE_3 = "MOVES_LINE_3",
    MOVES_LINE_4 = "MOVES_LINE_4",
    FOUR_MOVES = "FOUR_MOVES",
    THREE_MOVES = "THREE_MOVES",
    TWO_MOVES = "TWO_MOVES",
    ONE_MOVE = "ONE_MOVE",
    MOVE_VALUE = "MOVE_VALUE",
    _ = "_",
}
export interface POKESOL_TEXT {
    kind: ASTKinds.POKESOL_TEXT;
    line1: LINE1;
    line2: LINE2;
    line3: LINE3;
    line4: LINE4;
    line5: LINE5;
}
export type LINE1 = LINE1_1 | LINE1_2;
export type LINE1_1 = POKEMON_AND_ITEM_LINE;
export type LINE1_2 = POKEMON_LINE;
export interface POKEMON_AND_ITEM_LINE {
    kind: ASTKinds.POKEMON_AND_ITEM_LINE;
    pokemon: POKEMON;
    item: ITEM;
}
export interface POKEMON_LINE {
    kind: ASTKinds.POKEMON_LINE;
    pokemon: POKEMON;
}
export type POKEMON = POKEMON_VALUE;
export type ITEM = ITEM_VALUE;
export type POKEMON_VALUE = string;
export type ITEM_VALUE = string;
export type LINE2 = LINE2_1 | LINE2_2 | LINE2_3;
export type LINE2_1 = ABILITY_AND_TERATYPE_LINE;
export type LINE2_2 = ABILITY_LINE;
export type LINE2_3 = TERATYPE_LINE;
export interface ABILITY_AND_TERATYPE_LINE {
    kind: ASTKinds.ABILITY_AND_TERATYPE_LINE;
    ability: ABILITY;
    teratype: TERATYPE;
}
export interface ABILITY_LINE {
    kind: ASTKinds.ABILITY_LINE;
    ability: ABILITY;
}
export interface TERATYPE_LINE {
    kind: ASTKinds.TERATYPE_LINE;
    teratype: TERATYPE;
}
export interface ABILITY {
    kind: ASTKinds.ABILITY;
    value: ABILITY_VALUE;
}
export interface TERATYPE {
    kind: ASTKinds.TERATYPE;
    value: TERATYPE_VALUE;
}
export type ABILITY_VALUE = string;
export type TERATYPE_VALUE = string;
export type LINE3 = LINE3_1 | LINE3_2 | LINE3_3;
export type LINE3_1 = NATURE_AND_IV_LINE;
export type LINE3_2 = NATURE_LINE;
export type LINE3_3 = IV_LINE;
export interface NATURE_AND_IV_LINE {
    kind: ASTKinds.NATURE_AND_IV_LINE;
    nature: NATURE;
    iv: IV;
}
export interface NATURE_LINE {
    kind: ASTKinds.NATURE_LINE;
    nature: NATURE;
}
export interface IV_LINE {
    kind: ASTKinds.IV_LINE;
    iv: IV;
}
export interface NATURE {
    kind: ASTKinds.NATURE;
    value: NATURE_VALUE;
}
export interface IV {
    kind: ASTKinds.IV;
    h: Nullable<IV_H>;
    a: Nullable<IV_A>;
    b: Nullable<IV_B>;
    c: Nullable<IV_C>;
    d: Nullable<IV_D>;
    s: Nullable<IV_S>;
}
export interface IV_H {
    kind: ASTKinds.IV_H;
    value: IV_VALUE;
}
export interface IV_A {
    kind: ASTKinds.IV_A;
    value: IV_VALUE;
}
export interface IV_B {
    kind: ASTKinds.IV_B;
    value: IV_VALUE;
}
export interface IV_C {
    kind: ASTKinds.IV_C;
    value: IV_VALUE;
}
export interface IV_D {
    kind: ASTKinds.IV_D;
    value: IV_VALUE;
}
export interface IV_S {
    kind: ASTKinds.IV_S;
    value: IV_VALUE;
}
export type NATURE_VALUE = string;
export type IV_VALUE = string;
export type LINE4 = STATS_LINE;
export type STATS_LINE = STATS;
export interface STATS {
    kind: ASTKinds.STATS;
    h: STAT;
    a: STAT;
    b: STAT;
    c: STAT;
    d: STAT;
    s: STAT;
}
export type STAT = STAT_1 | STAT_2;
export type STAT_1 = ACTUAL_AND_EV;
export type STAT_2 = ACTUAL;
export interface ACTUAL_AND_EV {
    kind: ASTKinds.ACTUAL_AND_EV;
    value: ACTUAL_VALUE;
    ev: EV_VALUE;
}
export interface ACTUAL {
    kind: ASTKinds.ACTUAL;
    value: ACTUAL_VALUE;
}
export type ACTUAL_VALUE = string;
export type EV_VALUE = string;
export type LINE5 = MOVES_LINE;
export type MOVES_LINE = MOVES_LINE_1 | MOVES_LINE_2 | MOVES_LINE_3 | MOVES_LINE_4;
export type MOVES_LINE_1 = FOUR_MOVES;
export type MOVES_LINE_2 = THREE_MOVES;
export type MOVES_LINE_3 = TWO_MOVES;
export type MOVES_LINE_4 = ONE_MOVE;
export interface FOUR_MOVES {
    kind: ASTKinds.FOUR_MOVES;
    move1: MOVE_VALUE;
    move2: MOVE_VALUE;
    move3: MOVE_VALUE;
    move4: MOVE_VALUE;
}
export interface THREE_MOVES {
    kind: ASTKinds.THREE_MOVES;
    move1: MOVE_VALUE;
    move2: MOVE_VALUE;
    move3: MOVE_VALUE;
}
export interface TWO_MOVES {
    kind: ASTKinds.TWO_MOVES;
    move1: MOVE_VALUE;
    move2: MOVE_VALUE;
}
export interface ONE_MOVE {
    kind: ASTKinds.ONE_MOVE;
    move1: MOVE_VALUE;
}
export type MOVE_VALUE = string;
export type _ = string;
export class Parser {
    private readonly input: string;
    private pos: PosInfo;
    private negating: boolean = false;
    private memoSafe: boolean = true;
    constructor(input: string) {
        this.pos = {overallPos: 0, line: 1, offset: 0};
        this.input = input;
    }
    public reset(pos: PosInfo) {
        this.pos = pos;
    }
    public finished(): boolean {
        return this.pos.overallPos === this.input.length;
    }
    public clearMemos(): void {
    }
    public matchPOKESOL_TEXT($$dpth: number, $$cr?: ErrorTracker): Nullable<POKESOL_TEXT> {
        return this.run<POKESOL_TEXT>($$dpth,
            () => {
                let $scope$line1: Nullable<LINE1>;
                let $scope$line2: Nullable<LINE2>;
                let $scope$line3: Nullable<LINE3>;
                let $scope$line4: Nullable<LINE4>;
                let $scope$line5: Nullable<LINE5>;
                let $$res: Nullable<POKESOL_TEXT> = null;
                if (true
                    && ($scope$line1 = this.matchLINE1($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:\n)`, "", $$dpth + 1, $$cr) !== null
                    && ($scope$line2 = this.matchLINE2($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:\n)`, "", $$dpth + 1, $$cr) !== null
                    && ($scope$line3 = this.matchLINE3($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:\n)`, "", $$dpth + 1, $$cr) !== null
                    && ($scope$line4 = this.matchLINE4($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:\n)`, "", $$dpth + 1, $$cr) !== null
                    && ($scope$line5 = this.matchLINE5($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.POKESOL_TEXT, line1: $scope$line1, line2: $scope$line2, line3: $scope$line3, line4: $scope$line4, line5: $scope$line5};
                }
                return $$res;
            });
    }
    public matchLINE1($$dpth: number, $$cr?: ErrorTracker): Nullable<LINE1> {
        return this.choice<LINE1>([
            () => this.matchLINE1_1($$dpth + 1, $$cr),
            () => this.matchLINE1_2($$dpth + 1, $$cr),
        ]);
    }
    public matchLINE1_1($$dpth: number, $$cr?: ErrorTracker): Nullable<LINE1_1> {
        return this.matchPOKEMON_AND_ITEM_LINE($$dpth + 1, $$cr);
    }
    public matchLINE1_2($$dpth: number, $$cr?: ErrorTracker): Nullable<LINE1_2> {
        return this.matchPOKEMON_LINE($$dpth + 1, $$cr);
    }
    public matchPOKEMON_AND_ITEM_LINE($$dpth: number, $$cr?: ErrorTracker): Nullable<POKEMON_AND_ITEM_LINE> {
        return this.run<POKEMON_AND_ITEM_LINE>($$dpth,
            () => {
                let $scope$pokemon: Nullable<POKEMON>;
                let $scope$item: Nullable<ITEM>;
                let $$res: Nullable<POKEMON_AND_ITEM_LINE> = null;
                if (true
                    && ($scope$pokemon = this.matchPOKEMON($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:@)`, "", $$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$item = this.matchITEM($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.POKEMON_AND_ITEM_LINE, pokemon: $scope$pokemon, item: $scope$item};
                }
                return $$res;
            });
    }
    public matchPOKEMON_LINE($$dpth: number, $$cr?: ErrorTracker): Nullable<POKEMON_LINE> {
        return this.run<POKEMON_LINE>($$dpth,
            () => {
                let $scope$pokemon: Nullable<POKEMON>;
                let $$res: Nullable<POKEMON_LINE> = null;
                if (true
                    && ($scope$pokemon = this.matchPOKEMON($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.POKEMON_LINE, pokemon: $scope$pokemon};
                }
                return $$res;
            });
    }
    public matchPOKEMON($$dpth: number, $$cr?: ErrorTracker): Nullable<POKEMON> {
        return this.matchPOKEMON_VALUE($$dpth + 1, $$cr);
    }
    public matchITEM($$dpth: number, $$cr?: ErrorTracker): Nullable<ITEM> {
        return this.matchITEM_VALUE($$dpth + 1, $$cr);
    }
    public matchPOKEMON_VALUE($$dpth: number, $$cr?: ErrorTracker): Nullable<POKEMON_VALUE> {
        return this.regexAccept(String.raw`(?:[0-9a-zA-Zぁ-んァ-ヶー一-龠・()♂♀%]+)`, "", $$dpth + 1, $$cr);
    }
    public matchITEM_VALUE($$dpth: number, $$cr?: ErrorTracker): Nullable<ITEM_VALUE> {
        return this.regexAccept(String.raw`(?:[ぁ-んァ-ヶ一]+)`, "", $$dpth + 1, $$cr);
    }
    public matchLINE2($$dpth: number, $$cr?: ErrorTracker): Nullable<LINE2> {
        return this.choice<LINE2>([
            () => this.matchLINE2_1($$dpth + 1, $$cr),
            () => this.matchLINE2_2($$dpth + 1, $$cr),
            () => this.matchLINE2_3($$dpth + 1, $$cr),
        ]);
    }
    public matchLINE2_1($$dpth: number, $$cr?: ErrorTracker): Nullable<LINE2_1> {
        return this.matchABILITY_AND_TERATYPE_LINE($$dpth + 1, $$cr);
    }
    public matchLINE2_2($$dpth: number, $$cr?: ErrorTracker): Nullable<LINE2_2> {
        return this.matchABILITY_LINE($$dpth + 1, $$cr);
    }
    public matchLINE2_3($$dpth: number, $$cr?: ErrorTracker): Nullable<LINE2_3> {
        return this.matchTERATYPE_LINE($$dpth + 1, $$cr);
    }
    public matchABILITY_AND_TERATYPE_LINE($$dpth: number, $$cr?: ErrorTracker): Nullable<ABILITY_AND_TERATYPE_LINE> {
        return this.run<ABILITY_AND_TERATYPE_LINE>($$dpth,
            () => {
                let $scope$ability: Nullable<ABILITY>;
                let $scope$teratype: Nullable<TERATYPE>;
                let $$res: Nullable<ABILITY_AND_TERATYPE_LINE> = null;
                if (true
                    && ($scope$ability = this.matchABILITY($$dpth + 1, $$cr)) !== null
                    && this.loopPlus<string>(() => this.regexAccept(String.raw`(?: )`, "", $$dpth + 1, $$cr)) !== null
                    && ($scope$teratype = this.matchTERATYPE($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.ABILITY_AND_TERATYPE_LINE, ability: $scope$ability, teratype: $scope$teratype};
                }
                return $$res;
            });
    }
    public matchABILITY_LINE($$dpth: number, $$cr?: ErrorTracker): Nullable<ABILITY_LINE> {
        return this.run<ABILITY_LINE>($$dpth,
            () => {
                let $scope$ability: Nullable<ABILITY>;
                let $$res: Nullable<ABILITY_LINE> = null;
                if (true
                    && ($scope$ability = this.matchABILITY($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.ABILITY_LINE, ability: $scope$ability};
                }
                return $$res;
            });
    }
    public matchTERATYPE_LINE($$dpth: number, $$cr?: ErrorTracker): Nullable<TERATYPE_LINE> {
        return this.run<TERATYPE_LINE>($$dpth,
            () => {
                let $scope$teratype: Nullable<TERATYPE>;
                let $$res: Nullable<TERATYPE_LINE> = null;
                if (true
                    && ($scope$teratype = this.matchTERATYPE($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.TERATYPE_LINE, teratype: $scope$teratype};
                }
                return $$res;
            });
    }
    public matchABILITY($$dpth: number, $$cr?: ErrorTracker): Nullable<ABILITY> {
        return this.run<ABILITY>($$dpth,
            () => {
                let $scope$value: Nullable<ABILITY_VALUE>;
                let $$res: Nullable<ABILITY> = null;
                if (true
                    && this.regexAccept(String.raw`(?:特性:)`, "", $$dpth + 1, $$cr) !== null
                    && ($scope$value = this.matchABILITY_VALUE($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.ABILITY, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchTERATYPE($$dpth: number, $$cr?: ErrorTracker): Nullable<TERATYPE> {
        return this.run<TERATYPE>($$dpth,
            () => {
                let $scope$value: Nullable<TERATYPE_VALUE>;
                let $$res: Nullable<TERATYPE> = null;
                if (true
                    && this.regexAccept(String.raw`(?:テラスタル:)`, "", $$dpth + 1, $$cr) !== null
                    && ($scope$value = this.matchTERATYPE_VALUE($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.TERATYPE, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchABILITY_VALUE($$dpth: number, $$cr?: ErrorTracker): Nullable<ABILITY_VALUE> {
        return this.regexAccept(String.raw`(?:[ぁ-んァ-ヶー]+)`, "", $$dpth + 1, $$cr);
    }
    public matchTERATYPE_VALUE($$dpth: number, $$cr?: ErrorTracker): Nullable<TERATYPE_VALUE> {
        return this.regexAccept(String.raw`(?:[ぁ-んァ-ヶー]+)`, "", $$dpth + 1, $$cr);
    }
    public matchLINE3($$dpth: number, $$cr?: ErrorTracker): Nullable<LINE3> {
        return this.choice<LINE3>([
            () => this.matchLINE3_1($$dpth + 1, $$cr),
            () => this.matchLINE3_2($$dpth + 1, $$cr),
            () => this.matchLINE3_3($$dpth + 1, $$cr),
        ]);
    }
    public matchLINE3_1($$dpth: number, $$cr?: ErrorTracker): Nullable<LINE3_1> {
        return this.matchNATURE_AND_IV_LINE($$dpth + 1, $$cr);
    }
    public matchLINE3_2($$dpth: number, $$cr?: ErrorTracker): Nullable<LINE3_2> {
        return this.matchNATURE_LINE($$dpth + 1, $$cr);
    }
    public matchLINE3_3($$dpth: number, $$cr?: ErrorTracker): Nullable<LINE3_3> {
        return this.matchIV_LINE($$dpth + 1, $$cr);
    }
    public matchNATURE_AND_IV_LINE($$dpth: number, $$cr?: ErrorTracker): Nullable<NATURE_AND_IV_LINE> {
        return this.run<NATURE_AND_IV_LINE>($$dpth,
            () => {
                let $scope$nature: Nullable<NATURE>;
                let $scope$iv: Nullable<IV>;
                let $$res: Nullable<NATURE_AND_IV_LINE> = null;
                if (true
                    && ($scope$nature = this.matchNATURE($$dpth + 1, $$cr)) !== null
                    && this.loopPlus<string>(() => this.regexAccept(String.raw`(?: )`, "", $$dpth + 1, $$cr)) !== null
                    && ($scope$iv = this.matchIV($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.NATURE_AND_IV_LINE, nature: $scope$nature, iv: $scope$iv};
                }
                return $$res;
            });
    }
    public matchNATURE_LINE($$dpth: number, $$cr?: ErrorTracker): Nullable<NATURE_LINE> {
        return this.run<NATURE_LINE>($$dpth,
            () => {
                let $scope$nature: Nullable<NATURE>;
                let $$res: Nullable<NATURE_LINE> = null;
                if (true
                    && ($scope$nature = this.matchNATURE($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.NATURE_LINE, nature: $scope$nature};
                }
                return $$res;
            });
    }
    public matchIV_LINE($$dpth: number, $$cr?: ErrorTracker): Nullable<IV_LINE> {
        return this.run<IV_LINE>($$dpth,
            () => {
                let $scope$iv: Nullable<IV>;
                let $$res: Nullable<IV_LINE> = null;
                if (true
                    && ($scope$iv = this.matchIV($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.IV_LINE, iv: $scope$iv};
                }
                return $$res;
            });
    }
    public matchNATURE($$dpth: number, $$cr?: ErrorTracker): Nullable<NATURE> {
        return this.run<NATURE>($$dpth,
            () => {
                let $scope$value: Nullable<NATURE_VALUE>;
                let $$res: Nullable<NATURE> = null;
                if (true
                    && this.regexAccept(String.raw`(?:性格:)`, "", $$dpth + 1, $$cr) !== null
                    && ($scope$value = this.matchNATURE_VALUE($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.NATURE, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchIV($$dpth: number, $$cr?: ErrorTracker): Nullable<IV> {
        return this.run<IV>($$dpth,
            () => {
                let $scope$h: Nullable<Nullable<IV_H>>;
                let $scope$a: Nullable<Nullable<IV_A>>;
                let $scope$b: Nullable<Nullable<IV_B>>;
                let $scope$c: Nullable<Nullable<IV_C>>;
                let $scope$d: Nullable<Nullable<IV_D>>;
                let $scope$s: Nullable<Nullable<IV_S>>;
                let $$res: Nullable<IV> = null;
                if (true
                    && this.regexAccept(String.raw`(?:個体値:)`, "", $$dpth + 1, $$cr) !== null
                    && (($scope$h = this.matchIV_H($$dpth + 1, $$cr)) || true)
                    && this.match_($$dpth + 1, $$cr) !== null
                    && (($scope$a = this.matchIV_A($$dpth + 1, $$cr)) || true)
                    && this.match_($$dpth + 1, $$cr) !== null
                    && (($scope$b = this.matchIV_B($$dpth + 1, $$cr)) || true)
                    && this.match_($$dpth + 1, $$cr) !== null
                    && (($scope$c = this.matchIV_C($$dpth + 1, $$cr)) || true)
                    && this.match_($$dpth + 1, $$cr) !== null
                    && (($scope$d = this.matchIV_D($$dpth + 1, $$cr)) || true)
                    && this.match_($$dpth + 1, $$cr) !== null
                    && (($scope$s = this.matchIV_S($$dpth + 1, $$cr)) || true)
                ) {
                    $$res = {kind: ASTKinds.IV, h: $scope$h, a: $scope$a, b: $scope$b, c: $scope$c, d: $scope$d, s: $scope$s};
                }
                return $$res;
            });
    }
    public matchIV_H($$dpth: number, $$cr?: ErrorTracker): Nullable<IV_H> {
        return this.run<IV_H>($$dpth,
            () => {
                let $scope$value: Nullable<IV_VALUE>;
                let $$res: Nullable<IV_H> = null;
                if (true
                    && this.regexAccept(String.raw`(?:H)`, "", $$dpth + 1, $$cr) !== null
                    && ($scope$value = this.matchIV_VALUE($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.IV_H, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchIV_A($$dpth: number, $$cr?: ErrorTracker): Nullable<IV_A> {
        return this.run<IV_A>($$dpth,
            () => {
                let $scope$value: Nullable<IV_VALUE>;
                let $$res: Nullable<IV_A> = null;
                if (true
                    && this.regexAccept(String.raw`(?:A)`, "", $$dpth + 1, $$cr) !== null
                    && ($scope$value = this.matchIV_VALUE($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.IV_A, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchIV_B($$dpth: number, $$cr?: ErrorTracker): Nullable<IV_B> {
        return this.run<IV_B>($$dpth,
            () => {
                let $scope$value: Nullable<IV_VALUE>;
                let $$res: Nullable<IV_B> = null;
                if (true
                    && this.regexAccept(String.raw`(?:B)`, "", $$dpth + 1, $$cr) !== null
                    && ($scope$value = this.matchIV_VALUE($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.IV_B, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchIV_C($$dpth: number, $$cr?: ErrorTracker): Nullable<IV_C> {
        return this.run<IV_C>($$dpth,
            () => {
                let $scope$value: Nullable<IV_VALUE>;
                let $$res: Nullable<IV_C> = null;
                if (true
                    && this.regexAccept(String.raw`(?:C)`, "", $$dpth + 1, $$cr) !== null
                    && ($scope$value = this.matchIV_VALUE($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.IV_C, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchIV_D($$dpth: number, $$cr?: ErrorTracker): Nullable<IV_D> {
        return this.run<IV_D>($$dpth,
            () => {
                let $scope$value: Nullable<IV_VALUE>;
                let $$res: Nullable<IV_D> = null;
                if (true
                    && this.regexAccept(String.raw`(?:D)`, "", $$dpth + 1, $$cr) !== null
                    && ($scope$value = this.matchIV_VALUE($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.IV_D, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchIV_S($$dpth: number, $$cr?: ErrorTracker): Nullable<IV_S> {
        return this.run<IV_S>($$dpth,
            () => {
                let $scope$value: Nullable<IV_VALUE>;
                let $$res: Nullable<IV_S> = null;
                if (true
                    && this.regexAccept(String.raw`(?:S)`, "", $$dpth + 1, $$cr) !== null
                    && ($scope$value = this.matchIV_VALUE($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.IV_S, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchNATURE_VALUE($$dpth: number, $$cr?: ErrorTracker): Nullable<NATURE_VALUE> {
        return this.regexAccept(String.raw`(?:[ぁ-ん]+)`, "", $$dpth + 1, $$cr);
    }
    public matchIV_VALUE($$dpth: number, $$cr?: ErrorTracker): Nullable<IV_VALUE> {
        return this.regexAccept(String.raw`(?:0|[1-9][0-9]*)`, "", $$dpth + 1, $$cr);
    }
    public matchLINE4($$dpth: number, $$cr?: ErrorTracker): Nullable<LINE4> {
        return this.matchSTATS_LINE($$dpth + 1, $$cr);
    }
    public matchSTATS_LINE($$dpth: number, $$cr?: ErrorTracker): Nullable<STATS_LINE> {
        return this.matchSTATS($$dpth + 1, $$cr);
    }
    public matchSTATS($$dpth: number, $$cr?: ErrorTracker): Nullable<STATS> {
        return this.run<STATS>($$dpth,
            () => {
                let $scope$h: Nullable<STAT>;
                let $scope$a: Nullable<STAT>;
                let $scope$b: Nullable<STAT>;
                let $scope$c: Nullable<STAT>;
                let $scope$d: Nullable<STAT>;
                let $scope$s: Nullable<STAT>;
                let $$res: Nullable<STATS> = null;
                if (true
                    && ($scope$h = this.matchSTAT($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:-)`, "", $$dpth + 1, $$cr) !== null
                    && ($scope$a = this.matchSTAT($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:-)`, "", $$dpth + 1, $$cr) !== null
                    && ($scope$b = this.matchSTAT($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:-)`, "", $$dpth + 1, $$cr) !== null
                    && ($scope$c = this.matchSTAT($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:-)`, "", $$dpth + 1, $$cr) !== null
                    && ($scope$d = this.matchSTAT($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:-)`, "", $$dpth + 1, $$cr) !== null
                    && ($scope$s = this.matchSTAT($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.STATS, h: $scope$h, a: $scope$a, b: $scope$b, c: $scope$c, d: $scope$d, s: $scope$s};
                }
                return $$res;
            });
    }
    public matchSTAT($$dpth: number, $$cr?: ErrorTracker): Nullable<STAT> {
        return this.choice<STAT>([
            () => this.matchSTAT_1($$dpth + 1, $$cr),
            () => this.matchSTAT_2($$dpth + 1, $$cr),
        ]);
    }
    public matchSTAT_1($$dpth: number, $$cr?: ErrorTracker): Nullable<STAT_1> {
        return this.matchACTUAL_AND_EV($$dpth + 1, $$cr);
    }
    public matchSTAT_2($$dpth: number, $$cr?: ErrorTracker): Nullable<STAT_2> {
        return this.matchACTUAL($$dpth + 1, $$cr);
    }
    public matchACTUAL_AND_EV($$dpth: number, $$cr?: ErrorTracker): Nullable<ACTUAL_AND_EV> {
        return this.run<ACTUAL_AND_EV>($$dpth,
            () => {
                let $scope$value: Nullable<ACTUAL_VALUE>;
                let $scope$ev: Nullable<EV_VALUE>;
                let $$res: Nullable<ACTUAL_AND_EV> = null;
                if (true
                    && ($scope$value = this.matchACTUAL_VALUE($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:\()`, "", $$dpth + 1, $$cr) !== null
                    && ($scope$ev = this.matchEV_VALUE($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:\))`, "", $$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.ACTUAL_AND_EV, value: $scope$value, ev: $scope$ev};
                }
                return $$res;
            });
    }
    public matchACTUAL($$dpth: number, $$cr?: ErrorTracker): Nullable<ACTUAL> {
        return this.run<ACTUAL>($$dpth,
            () => {
                let $scope$value: Nullable<ACTUAL_VALUE>;
                let $$res: Nullable<ACTUAL> = null;
                if (true
                    && ($scope$value = this.matchACTUAL_VALUE($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.ACTUAL, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchACTUAL_VALUE($$dpth: number, $$cr?: ErrorTracker): Nullable<ACTUAL_VALUE> {
        return this.regexAccept(String.raw`(?:[1-9][0-9]*)`, "", $$dpth + 1, $$cr);
    }
    public matchEV_VALUE($$dpth: number, $$cr?: ErrorTracker): Nullable<EV_VALUE> {
        return this.regexAccept(String.raw`(?:[1-9][0-9]*)`, "", $$dpth + 1, $$cr);
    }
    public matchLINE5($$dpth: number, $$cr?: ErrorTracker): Nullable<LINE5> {
        return this.matchMOVES_LINE($$dpth + 1, $$cr);
    }
    public matchMOVES_LINE($$dpth: number, $$cr?: ErrorTracker): Nullable<MOVES_LINE> {
        return this.choice<MOVES_LINE>([
            () => this.matchMOVES_LINE_1($$dpth + 1, $$cr),
            () => this.matchMOVES_LINE_2($$dpth + 1, $$cr),
            () => this.matchMOVES_LINE_3($$dpth + 1, $$cr),
            () => this.matchMOVES_LINE_4($$dpth + 1, $$cr),
        ]);
    }
    public matchMOVES_LINE_1($$dpth: number, $$cr?: ErrorTracker): Nullable<MOVES_LINE_1> {
        return this.matchFOUR_MOVES($$dpth + 1, $$cr);
    }
    public matchMOVES_LINE_2($$dpth: number, $$cr?: ErrorTracker): Nullable<MOVES_LINE_2> {
        return this.matchTHREE_MOVES($$dpth + 1, $$cr);
    }
    public matchMOVES_LINE_3($$dpth: number, $$cr?: ErrorTracker): Nullable<MOVES_LINE_3> {
        return this.matchTWO_MOVES($$dpth + 1, $$cr);
    }
    public matchMOVES_LINE_4($$dpth: number, $$cr?: ErrorTracker): Nullable<MOVES_LINE_4> {
        return this.matchONE_MOVE($$dpth + 1, $$cr);
    }
    public matchFOUR_MOVES($$dpth: number, $$cr?: ErrorTracker): Nullable<FOUR_MOVES> {
        return this.run<FOUR_MOVES>($$dpth,
            () => {
                let $scope$move1: Nullable<MOVE_VALUE>;
                let $scope$move2: Nullable<MOVE_VALUE>;
                let $scope$move3: Nullable<MOVE_VALUE>;
                let $scope$move4: Nullable<MOVE_VALUE>;
                let $$res: Nullable<FOUR_MOVES> = null;
                if (true
                    && ($scope$move1 = this.matchMOVE_VALUE($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:/)`, "", $$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$move2 = this.matchMOVE_VALUE($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:/)`, "", $$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$move3 = this.matchMOVE_VALUE($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:/)`, "", $$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$move4 = this.matchMOVE_VALUE($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.FOUR_MOVES, move1: $scope$move1, move2: $scope$move2, move3: $scope$move3, move4: $scope$move4};
                }
                return $$res;
            });
    }
    public matchTHREE_MOVES($$dpth: number, $$cr?: ErrorTracker): Nullable<THREE_MOVES> {
        return this.run<THREE_MOVES>($$dpth,
            () => {
                let $scope$move1: Nullable<MOVE_VALUE>;
                let $scope$move2: Nullable<MOVE_VALUE>;
                let $scope$move3: Nullable<MOVE_VALUE>;
                let $$res: Nullable<THREE_MOVES> = null;
                if (true
                    && ($scope$move1 = this.matchMOVE_VALUE($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:/)`, "", $$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$move2 = this.matchMOVE_VALUE($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:/)`, "", $$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$move3 = this.matchMOVE_VALUE($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.THREE_MOVES, move1: $scope$move1, move2: $scope$move2, move3: $scope$move3};
                }
                return $$res;
            });
    }
    public matchTWO_MOVES($$dpth: number, $$cr?: ErrorTracker): Nullable<TWO_MOVES> {
        return this.run<TWO_MOVES>($$dpth,
            () => {
                let $scope$move1: Nullable<MOVE_VALUE>;
                let $scope$move2: Nullable<MOVE_VALUE>;
                let $$res: Nullable<TWO_MOVES> = null;
                if (true
                    && ($scope$move1 = this.matchMOVE_VALUE($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:/)`, "", $$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$move2 = this.matchMOVE_VALUE($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.TWO_MOVES, move1: $scope$move1, move2: $scope$move2};
                }
                return $$res;
            });
    }
    public matchONE_MOVE($$dpth: number, $$cr?: ErrorTracker): Nullable<ONE_MOVE> {
        return this.run<ONE_MOVE>($$dpth,
            () => {
                let $scope$move1: Nullable<MOVE_VALUE>;
                let $$res: Nullable<ONE_MOVE> = null;
                if (true
                    && ($scope$move1 = this.matchMOVE_VALUE($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.ONE_MOVE, move1: $scope$move1};
                }
                return $$res;
            });
    }
    public matchMOVE_VALUE($$dpth: number, $$cr?: ErrorTracker): Nullable<MOVE_VALUE> {
        return this.regexAccept(String.raw`(?:[０-９ぁ-んァ-ヶー・]+)`, "", $$dpth + 1, $$cr);
    }
    public match_($$dpth: number, $$cr?: ErrorTracker): Nullable<_> {
        return this.regexAccept(String.raw`(?:\s*)`, "", $$dpth + 1, $$cr);
    }
    public test(): boolean {
        const mrk = this.mark();
        const res = this.matchPOKESOL_TEXT(0);
        const ans = res !== null;
        this.reset(mrk);
        return ans;
    }
    public parse(): ParseResult {
        const mrk = this.mark();
        const res = this.matchPOKESOL_TEXT(0);
        if (res)
            return {ast: res, errs: []};
        this.reset(mrk);
        const rec = new ErrorTracker();
        this.clearMemos();
        this.matchPOKESOL_TEXT(0, rec);
        const err = rec.getErr()
        return {ast: res, errs: err !== null ? [err] : []}
    }
    public mark(): PosInfo {
        return this.pos;
    }
    // @ts-ignore: loopPlus may not be called
    private loopPlus<T>(func: $$RuleType<T>): Nullable<[T, ...T[]]> {
        return this.loop(func, 1, -1) as Nullable<[T, ...T[]]>;
    }
    private loop<T>(func: $$RuleType<T>, lb: number, ub: number): Nullable<T[]> {
        const mrk = this.mark();
        const res: T[] = [];
        while (ub === -1 || res.length < ub) {
            const preMrk = this.mark();
            const t = func();
            if (t === null || this.pos.overallPos === preMrk.overallPos) {
                break;
            }
            res.push(t);
        }
        if (res.length >= lb) {
            return res;
        }
        this.reset(mrk);
        return null;
    }
    private run<T>($$dpth: number, fn: $$RuleType<T>): Nullable<T> {
        const mrk = this.mark();
        const res = fn()
        if (res !== null)
            return res;
        this.reset(mrk);
        return null;
    }
    // @ts-ignore: choice may not be called
    private choice<T>(fns: Array<$$RuleType<T>>): Nullable<T> {
        for (const f of fns) {
            const res = f();
            if (res !== null) {
                return res;
            }
        }
        return null;
    }
    private regexAccept(match: string, mods: string, dpth: number, cr?: ErrorTracker): Nullable<string> {
        return this.run<string>(dpth,
            () => {
                const reg = new RegExp(match, "y" + mods);
                const mrk = this.mark();
                reg.lastIndex = mrk.overallPos;
                const res = this.tryConsume(reg);
                if(cr) {
                    cr.record(mrk, res, {
                        kind: "RegexMatch",
                        // We substring from 3 to len - 1 to strip off the
                        // non-capture group syntax added as a WebKit workaround
                        literal: match.substring(3, match.length - 1),
                        negated: this.negating,
                    });
                }
                return res;
            });
    }
    private tryConsume(reg: RegExp): Nullable<string> {
        const res = reg.exec(this.input);
        if (res) {
            let lineJmp = 0;
            let lind = -1;
            for (let i = 0; i < res[0].length; ++i) {
                if (res[0][i] === "\n") {
                    ++lineJmp;
                    lind = i;
                }
            }
            this.pos = {
                overallPos: reg.lastIndex,
                line: this.pos.line + lineJmp,
                offset: lind === -1 ? this.pos.offset + res[0].length : (res[0].length - lind - 1)
            };
            return res[0];
        }
        return null;
    }
    // @ts-ignore: noConsume may not be called
    private noConsume<T>(fn: $$RuleType<T>): Nullable<T> {
        const mrk = this.mark();
        const res = fn();
        this.reset(mrk);
        return res;
    }
    // @ts-ignore: negate may not be called
    private negate<T>(fn: $$RuleType<T>): Nullable<boolean> {
        const mrk = this.mark();
        const oneg = this.negating;
        this.negating = !oneg;
        const res = fn();
        this.negating = oneg;
        this.reset(mrk);
        return res === null ? true : null;
    }
    // @ts-ignore: Memoise may not be used
    private memoise<K>(rule: $$RuleType<K>, memo: Map<number, [Nullable<K>, PosInfo]>): Nullable<K> {
        const $scope$pos = this.mark();
        const $scope$memoRes = memo.get($scope$pos.overallPos);
        if(this.memoSafe && $scope$memoRes !== undefined) {
        this.reset($scope$memoRes[1]);
        return $scope$memoRes[0];
        }
        const $scope$result = rule();
        if(this.memoSafe)
        memo.set($scope$pos.overallPos, [$scope$result, this.mark()]);
        return $scope$result;
    }
}
export function parse(s: string): ParseResult {
    const p = new Parser(s);
    return p.parse();
}
export interface ParseResult {
    ast: Nullable<POKESOL_TEXT>;
    errs: SyntaxErr[];
}
export interface PosInfo {
    readonly overallPos: number;
    readonly line: number;
    readonly offset: number;
}
export interface RegexMatch {
    readonly kind: "RegexMatch";
    readonly negated: boolean;
    readonly literal: string;
}
export type EOFMatch = { kind: "EOF"; negated: boolean };
export type MatchAttempt = RegexMatch | EOFMatch;
export class SyntaxErr {
    public pos: PosInfo;
    public expmatches: MatchAttempt[];
    constructor(pos: PosInfo, expmatches: MatchAttempt[]) {
        this.pos = pos;
        this.expmatches = [...expmatches];
    }
    public toString(): string {
        return `Syntax Error at line ${this.pos.line}:${this.pos.offset}. Expected one of ${this.expmatches.map(x => x.kind === "EOF" ? " EOF" : ` ${x.negated ? 'not ': ''}'${x.literal}'`)}`;
    }
}
class ErrorTracker {
    private mxpos: PosInfo = {overallPos: -1, line: -1, offset: -1};
    private regexset: Set<string> = new Set();
    private pmatches: MatchAttempt[] = [];
    public record(pos: PosInfo, result: any, att: MatchAttempt) {
        if ((result === null) === att.negated)
            return;
        if (pos.overallPos > this.mxpos.overallPos) {
            this.mxpos = pos;
            this.pmatches = [];
            this.regexset.clear()
        }
        if (this.mxpos.overallPos === pos.overallPos) {
            if(att.kind === "RegexMatch") {
                if(!this.regexset.has(att.literal))
                    this.pmatches.push(att);
                this.regexset.add(att.literal);
            } else {
                this.pmatches.push(att);
            }
        }
    }
    public getErr(): SyntaxErr | null {
        if (this.mxpos.overallPos !== -1)
            return new SyntaxErr(this.mxpos, this.pmatches);
        return null;
    }
}